---
title: Mockowanie out
date: '2019-09-04'
draft: false
tags:
  - 'Lang pl'
  - 'TDD'
  - 'C-Sharp'
  - 'Moq'
summary: 'W jaki spos贸b mockowa metody ze sowem kluczowym out?'
---

W jaki spos贸b mockowa (za pomoc Moq) metody ze sowem kluczowym out? Przyjrzyjmy si bli偶ej problemowi...

Przypumy, 偶e posiadamy klas, kt贸ra parsuje warto typu string na interfejs numeryczny o nazwie `INumber`. Metoda parsowania to wzorzec Try-Parse, niemal identyczny do metod typu `int.TryParse`. Obydwa interfejsy wygldaj nastpujco:

```csharp
public interface INumberParser
{
    bool TryParse(string numberToBeParsed, out INumber number);
}

public interface INumber
{
    int Int32 { get; set; }
}
```

Aby zamockowa metod `TryParse` klasy `INumberConverter` nale偶y posu偶y si nastpujcym przepisem:

1. Przy setupie mocka musimy zdefiniowa odpowiedni matcher dla parametru `number`. Zwyky matcher `It.IsAny` w tym przypadku nie zadziaa. Musimy posu偶y si matcherem `It.Ref<>.IsAny`.
1. Jak zwr贸ci warto typu bool metody oraz przypisa warto zmiennej out? Tutaj musimy zdefiniowa odpowiedni delegat tego samego typu co metoda `TryParse`.

Cay test oraz wspomniany delegat wygldaj nastpujco:

```csharp
[Test]
public void Test()
{
    // Setup the mocking of out:
    var numberConverter = Mock.Of<INumberParser>();

    Mock.Get(numberConverter)
        .Setup(x => x.TryParse(It.IsAny<string>(), out It.Ref<INumber>.IsAny))
        .Returns(new TryParse((string s, out INumber n) =>
        {
            n = Mock.Of<INumber>(num => num.Int32 == 456);
            return true;
        }));
        
    // Act:
    var tryGet = numberConverter.TryParse("any number", out var number);

    // Assert that values are properly set:
    Assert.That(tryGet, Is.True);
    Assert.That(number.Int32, Is.EqualTo(456));
}

private delegate bool TryParse(string s, out INumber n);
```

Drugi spos贸b to utworzenie nowego mocka i przypisanie wartoci w metodzie `Callback`:

```csharp
[Test]
public void Test2()
{
    // Setup the mocking of out:
    var numberConverter = Mock.Of<INumberParser>();

    var mockedNumber = Mock.Of<INumber>();

    Mock.Get(numberConverter)
        .Setup(x => x.TryParse(It.IsAny<string>(), out mockedNumber))
        .Callback(() => mockedNumber.Int32 = 456)
        .Returns(true);

    // Act:
    var tryGet = numberConverter.TryParse("any number", out var number);

    // Assert that values are properly set:
    Assert.That(tryGet, Is.True);
    Assert.That(number.Int32, Is.EqualTo(456));
}
```

Kt贸ra metoda jest lepsza? Pierwsza jest nieco bardziej skomplikowana, ale bardziej ekspresywna, a z kolei druga, prostsza, nie wymaga u偶ycia bardziej zaawansowanych technik typu matcher dla `Ref` czy definicja delegata w kontekcie zwracania wartoci. Wyb贸r pozostawiam Tobie 

Cay przykad jest do cignicia tutaj: https://github.com/dariusz-wozniak/MockingOutDemo
